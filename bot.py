#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ASSISTENTE PESSOAL AVAN√áADO - SISTEMA DE ALTA COMPLEXIDADE
Com capacidade interpretativa profunda de linguagem natural
"""

import os
import sqlite3
import datetime
import re
import sys
from enum import Enum
from typing import Dict, List, Tuple, Optional

print("üß† Iniciando Assistente com Intelig√™ncia Avan√ßada...")

BOT_TOKEN = "SEU_TOKEN_AQUI"

if "SEU_TOKEN" in BOT_TOKEN:
    print("‚ùå Configure o token!")
    sys.exit(1)

try:
    from telegram import Update
    from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext
    print("‚úÖ M√≥dulos carregados")
except ImportError as e:
    print(f"‚ùå Erro: {e}")
    sys.exit(1)

# =============================================
# ENUMS E ESTRUTURAS COMPLEXAS
# =============================================

class TipoIntencao(Enum):
    AGENDAR = "agendar"
    CONSULTAR = "consultar" 
    LISTA_COMPRAS = "lista_compras"
    LEMBRETE = "lembrete"
    SAUDACAO = "saudacao"
    AGRADECIMENTO = "agradecimento"
    DESCONHECIDO = "desconhecido"

class EntidadeTemporal:
    def __init__(self):
        self.data = None
        self.hora = None
        self.periodo_dia = None
        self.duracao = None
        self.repeticao = None

class EntidadeNomeada:
    def __init__(self):
        self.pessoas = []
        self.locais = []
        self.organizacoes = []

class EstruturaFrase:
    def __init__(self):
        self.verbo_principal = None
        self.sujeito = None
        self.objeto = None
        self.complementos = []
        self.adjuntos_temporais = []
        self.adjuntos_locais = []

# =============================================
# ANALISADOR SINT√ÅTICO AVAN√áADO
# =============================================

class AnalisadorSintatico:
    def __init__(self):
        # VERBOS DE A√á√ÉO EXPANDIDOS
        self.verbos_acao = {
            'telefonar', 'ligar', 'chamar', 'discar', 'contactar',
            'visitar', 'encontrar', 'ver', 'encontrar', 'ir ver',
            'buscar', 'apanhar', 'pegar', 'levar', 'trazer',
            'marcar', 'agendar', 'marca√ß√£o', 'agendamento',
            'consultar', 'visitar', 'passar no', 'ir ao', 'dirigir',
            'reunir', 'encontrar', 'conversar', 'falar'
        }
        
        # PESSOAS COMUNS (PODE EXPANDIR)
        self.pessoas_comuns = {
            'pai', 'm√£e', 'm√£e', 'av√¥', 'av√≥', 'filho', 'filha',
            'marido', 'esposa', 'mulher', 'namorado', 'namorada',
            'amigo', 'amiga', 'colega', 'chefe', 'cliente', 'm√©dico'
        }
        
        # LOCAIS COMUNS
        self.locais_comuns = {
            'hospital', 'escola', 'trabalho', 'casa', 'escrit√≥rio',
            'consult√≥rio', 'supermercado', 'mercado', 'farm√°cia',
            'shopping', 'centro comercial', 'aeroporto'
        }

    def analisar_estrutura(self, texto: str) -> EstruturaFrase:
        """An√°lise sint√°tica profunda da frase"""
        estrutura = EstruturaFrase()
        texto_lower = texto.lower()
        
        # TOKENIZA√á√ÉO E AN√ÅLISE B√ÅSICA
        palavras = texto_lower.split()
        
        # IDENTIFICAR VERBO PRINCIPAL
        for palavra in palavras:
            if palavra in self.verbos_acao:
                estrutura.verbo_principal = palavra
                break
        
        # IDENTIFICAR SUJEITO (antes do verbo)
        if estrutura.verbo_principal:
            idx_verbo = palavras.index(estrutura.verbo_principal)
            estrutura.sujeito = ' '.join(palavras[:idx_verbo]) if idx_verbo > 0 else "eu"
        
        # IDENTIFICAR OBJETO (depois do verbo)
        if estrutura.verbo_principal:
            idx_verbo = palavras.index(estrutura.verbo_principal)
            estrutura.objeto = ' '.join(palavras[idx_verbo + 1:])
        
        # EXTRAIR ENTIDADES NOMEADAS
        entidades = self.extrair_entidades_nomeadas(texto_lower)
        estrutura.complementos.extend(entidades.pessoas)
        estrutura.complementos.extend(entidades.locais)
        
        # EXTRAIR ADJUNTOS TEMPORAIS
        estrutura.adjuntos_temporais = self.extrair_referencias_temporais(texto_lower)
        
        # EXTRAIR ADJUNTOS LOCAIS
        estrutura.adjuntos_locais = self.extrair_referencias_locais(texto_lower)
        
        return estrutura

    def extrair_entidades_nomeadas(self, texto: str) -> EntidadeNomeada:
        """Extrai pessoas, locais e organiza√ß√µes do texto"""
        entidades = EntidadeNomeada()
        
        # PESSOAS
        for pessoa in self.pessoas_comuns:
            if pessoa in texto:
                entidades.pessoas.append(pessoa)
        
        # LOCAIS
        for local in self.locais_comuns:
            if local in texto:
                entidades.locais.append(local)
        
        return entidades

    def extrair_referencias_temporais(self, texto: str) -> List[str]:
        """Extrai todas as refer√™ncias temporais"""
        temporais = []
        
        # PADR√ïES TEMPORAIS COMPLEXOS
        padroes = [
            r'(\d{1,2})[h: ]?(\d{0,2})\s*(da\s+(manh√£|tarde|noite))',
            r'(\d{1,2})\s*(horas)\s*(da\s+(manh√£|tarde|noite))',
            r'(\d{1,2})[h: ]?(\d{0,2})\s*(h)',
            r'(\d{1,2})\s*(em ponto)',
            r'(meio-dia|meio dia)',
            r'(meia-noite|meia noite)',
            r'(amanh√£|hoje|depois de amanh√£)',
            r'(segunda|ter√ßa|quarta|quinta|sexta|s√°bado|domingo)'
        ]
        
        for padrao in padroes:
            matches = re.finditer(padrao, texto, re.IGNORECASE)
            for match in matches:
                temporais.append(match.group())
        
        return temporais

    def extrair_referencias_locais(self, texto: str) -> List[str]:
        """Extrai refer√™ncias locais"""
        locais = []
        
        for local in self.locais_comuns:
            if local in texto:
                locais.append(local)
        
        return locais

# =============================================
# PROCESSADOR TEMPORAL AVAN√áADO
# =============================================

class ProcessadorTemporal:
    def __init__(self):
        self.dias_semana = {
            'segunda': 0, 'ter√ßa': 1, 'quarta': 2, 'quinta': 3,
            'segunda-feira': 0, 'ter√ßa-feira': 1, 'quarta-feira': 2, 'quinta-feira': 3,
            'sexta': 4, 's√°bado': 5, 'domingo': 6,
            'sexta-feira': 4
        }
        
        self.periodos_dia = {
            'manh√£': (6, 12),
            'tarde': (12, 18), 
            'noite': (18, 24),
            'madrugada': (0, 6)
        }

    def processar_temporalidade(self, texto: str) -> EntidadeTemporal:
        """Processamento temporal de alta precis√£o"""
        temporal = EntidadeTemporal()
        texto_lower = texto.lower()
        
        # DATA PRIMEIRO
        temporal.data = self.extrair_data(texto_lower)
        
        # HORA COM PER√çODO DO DIA
        hora_info = self.extrair_hora_com_periodo(texto_lower)
        temporal.hora = hora_info['hora']
        temporal.periodo_dia = hora_info['periodo']
        
        return temporal

    def extrair_data(self, texto: str) -> str:
        """Extrai data com alta precis√£o"""
        hoje = datetime.datetime.now()
        
        # DIAS DA SEMANA
        for dia, offset in self.dias_semana.items():
            if dia in texto:
                dias_diferenca = (offset - hoje.weekday()) % 7
                data_alvo = hoje + datetime.datetime.timedelta(days=dias_diferenca)
                return data_alvo.strftime('%d/%m/%Y')
        
        # EXPRESS√ïES TEMPORAIS
        if 'amanh√£' in texto:
            return (hoje + datetime.timedelta(days=1)).strftime('%d/%m/%Y')
        elif 'depois de amanh√£' in texto:
            return (hoje + datetime.timedelta(days=2)).strftime('%d/%m/%Y')
        elif 'hoje' in texto:
            return hoje.strftime('%d/%m/%Y')
        
        # PADR√ÉO DD/MM ou DD-MM
        padrao_data = r'(\d{1,2})[/-](\d{1,2})'
        match = re.search(padrao_data, texto)
        if match:
            dia, mes = match.groups()
            ano = hoje.year
            return f"{int(dia):02d}/{int(mes):02d}/{ano}"
        
        return hoje.strftime('%d/%m/%Y')

    def extrair_hora_com_periodo(self, texto: str) -> Dict:
        """Extrai hora considerando per√≠odo do dia - CORRE√á√ÉO CR√çTICA"""
        # PADR√ÉO: "2:00 da tarde" ou "2 da tarde" ou "14h" ou "14:00"
        padrao_completo = r'(\d{1,2})[h: ]?(\d{0,2})?\s*(?:horas?)?\s*(?:da\s+)?(manh√£|tarde|noite|madrugada)?'
        matches = re.finditer(padrao_completo, texto, re.IGNORECASE)
        
        for match in matches:
            hora_str, minuto_str, periodo = match.groups()
            
            if hora_str:
                hora = int(hora_str)
                minutos = int(minuto_str) if minuto_str and minuto_str.isdigit() else 0
                
                # CORRE√á√ÉO DO BUG: Converter para formato 24h baseado no per√≠odo
                if periodo:
                    if periodo.lower() in ['tarde', 'noite'] and hora < 12:
                        hora += 12
                    elif periodo.lower() == 'madrugada' and hora > 12:
                        hora -= 12
                
                # Garantir que hora est√° no range correto
                hora = hora % 24
                
                return {
                    'hora': f"{hora:02d}:{minutos:02d}",
                    'periodo': periodo
                }
        
        # SE N√ÉO ENCONTROU, TENTA PADR√ïES SIMPLES
        padrao_simples = r'(\d{1,2})[h: ]?(\d{0,2})'
        match = re.search(padrao_simples, texto)
        if match:
            hora_str, minuto_str = match.groups()
            hora = int(hora_str) % 24
            minutos = int(minuto_str) if minuto_str and minuto_str.isdigit() else 0
            return {
                'hora': f"{hora:02d}:{minutos:02d}",
                'periodo': None
            }
        
        # PADR√ÉO DE TEXTO
        if 'meio-dia' in texto or 'meio dia' in texto:
            return {'hora': '12:00', 'periodo': 'tarde'}
        elif 'meia-noite' in texto or 'meia noite' in texto:
            return {'hora': '00:00', 'periodo': 'madrugada'}
        
        return {'hora': '09:00', 'periodo': None}

# =============================================
# CLASSIFICADOR DE INTEN√á√ïES AVAN√áADO
# =============================================

class ClassificadorIntencoes:
    def __init__(self):
        self.padroes_intencao = {
            TipoIntencao.AGENDAR: [
                r'\b(telefonar|ligar|visitar|encontrar|buscar|marcar|agendar|ir\s+ao|ir\s+ver)\b',
                r'\b(reuni√£o|consulta|compromisso|encontro)\b'
            ],
            TipoIntencao.LISTA_COMPRAS: [
                r'\b(comprar|preciso de|acabou|faltam|lista)\b',
                r'\b(leite|p√£o|arroz|feij√£o|supermercado|mercado)\b'
            ],
            TipoIntencao.CONSULTAR: [
                r'\b(que tenho|minha agenda|ver agenda|o que falta|consultar)\b'
            ],
            TipoIntencao.SAUDACAO: [
                r'\b(ol√°|oi|ola|bom dia|boa tarde|boa noite)\b'
            ]
        }

    def classificar(self, texto: str) -> TipoIntencao:
        """Classifica a inten√ß√£o principal do usu√°rio"""
        texto_lower = texto.lower()
        
        for intencao, padroes in self.padroes_intencao.items():
            for padrao in padroes:
                if re.search(padrao, texto_lower, re.IGNORECASE):
                    return intencao
        
        return TipoIntencao.DESCONHECIDO

# =============================================
# GERADOR DE RESPOSTAS CONTEXTUAIS
# =============================================

class GeradorRespostas:
    def __init__(self):
        self.analisador = AnalisadorSintatico()
        self.processador_temporal = ProcessadorTemporal()
        self.classificador = ClassificadorIntencoes()

    def gerar_resposta_agendamento(self, texto: str, estrutura: EstruturaFrase, temporal: EntidadeTemporal) -> str:
        """Gera resposta contextual para agendamento"""
        
        # T√çTULO INTELIGENTE BASEADO NA AN√ÅLISE
        if estrutura.verbo_principal == 'telefonar' or estrutura.verbo_principal == 'ligar':
            pessoa = next((p for p in estrutura.complementos if p in estrutura.analisador.pessoas_comuns), "contato")
            titulo = f"Telefonar para {pessoa}"
        
        elif estrutura.verbo_principal == 'visitar':
            local = next((l for l in estrutura.complementos if l in estrutura.analisador.locais_comuns), "local")
            pessoa = next((p for p in estrutura.complementos if p in estrutura.analisador.pessoas_comuns), None)
            if pessoa:
                titulo = f"Visitar {pessoa} no {local}"
            else:
                titulo = f"Visitar {local}"
        
        elif estrutura.verbo_principal:
            titulo = f"{estrutura.verbo_principal.title()} {estrutura.objeto or ''}"
        else:
            titulo = "Compromisso"
        
        # CONFIRMA√á√ÉO DETALHADA
        confirmacao = f"""‚úÖ **COMPROMISSO AGENDADO COM SUCESSO!**

üìÖ **{titulo}**
üóìÔ∏è **Data:** {temporal.data}
‚è∞ **Hora:** {temporal.hora}"""

        # DETALHES CONTEXTUAIS
        if estrutura.complementos:
            confirmacao += f"\nüë• **Envolvidos:** {', '.join(estrutura.complementos)}"
        
        if estrutura.adjuntos_locais:
            confirmacao += f"\nüìç **Local:** {', '.join(estrutura.adjuntos_locais)}"
        
        confirmacao += "\n\nüí° _Voc√™ receber√° um lembrete 15 minutos antes._"
        
        return confirmacao

# =============================================
# SISTEMA PRINCIPAL
# =============================================

class AssistenteAvancado:
    def __init__(self):
        self.db = sqlite3.connect('assistente_avancado.db', check_same_thread=False)
        self.criar_banco()
        self.analisador = AnalisadorSintatico()
        self.processador_temporal = ProcessadorTemporal()
        self.classificador = ClassificadorIntencoes()
        self.gerador_respostas = GeradorRespostas()
        print("‚úÖ Sistema de IA carregado")

    def criar_banco(self):
        cursor = self.db.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS compromissos_avancados (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                titulo TEXT,
                data TEXT,
                hora TEXT,
                pessoas TEXT,
                locais TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.db.commit()

    def processar_mensagem(self, texto: str, user_id: int) -> str:
        """Processamento principal com IA avan√ßada"""
        
        # AN√ÅLISE PROFUNDA
        estrutura = self.analisador.analisar_estrutura(texto)
        temporal = self.processador_temporal.processar_temporalidade(texto)
        intencao = self.classificador.classificar(texto)
        
        print(f"üîç AN√ÅLISE:")
        print(f"   Verbo: {estrutura.verbo_principal}")
        print(f"   Sujeito: {estrutura.sujeito}")
        print(f"   Objeto: {estrutura.objeto}")
        print(f"   Complementos: {estrutura.complementos}")
        print(f"   Temporais: {estrutura.adjuntos_temporais}")
        print(f"   Locais: {estrutura.adjuntos_locais}")
        print(f"   Data: {temporal.data}")
        print(f"   Hora: {temporal.hora}")
        print(f"   Inten√ß√£o: {intencao}")
        
        # A√á√ÉO BASEADA NA INTEN√á√ÉO
        if intencao == TipoIntencao.AGENDAR:
            return self.processar_agendamento(texto, estrutura, temporal, user_id)
        elif intencao == TipoIntencao.CONSULTAR:
            return self.processar_consulta(user_id)
        else:
            return self.gerar_resposta_geral(intencao, texto)

    def processar_agendamento(self, texto: str, estrutura: EstruturaFrase, temporal: EntidadeTemporal, user_id: int) -> str:
        """Processa agendamento com intelig√™ncia contextual"""
        
        # GERAR T√çTULO INTELIGENTE
        titulo = self.gerar_titulo_contextual(estrutura)
        
        # SALVAR NO BANCO
        cursor = self.db.cursor()
        cursor.execute(
            "INSERT INTO compromissos_avancados (user_id, titulo, data, hora, pessoas, locais) VALUES (?, ?, ?, ?, ?, ?)",
            (user_id, titulo, temporal.data, temporal.hora, 
             ','.join(estrutura.complementos), ','.join(estrutura.adjuntos_locais))
        )
        self.db.commit()
        
        # GERAR RESPOSTA
        return self.gerador_respostas.gerar_resposta_agendamento(texto, estrutura, temporal)

    def gerar_titulo_contextual(self, estrutura: EstruturaFrase) -> str:
        """Gera t√≠tulo inteligente baseado no contexto"""
        
        if estrutura.verbo_principal == 'telefonar':
            pessoa = next((p for p in estrutura.complementos), "contato")
            return f"Telefonar para {pessoa}"
        
        elif estrutura.verbo_principal == 'visitar':
            local = next((l for l in estrutura.complementos if l in self.analisador.locais_comuns), None)
            pessoa = next((p for p in estrutura.complementos if p in self.analisador.pessoas_comuns), None)
            
            if pessoa and local:
                return f"Visitar {pessoa} no {local}"
            elif local:
                return f"Visitar {local}"
            elif pessoa:
                return f"Visitar {pessoa}"
            else:
                return "Visita"
        
        elif estrutura.verbo_principal:
            acao = estrutura.verbo_principal.title()
            objeto = estrutura.objeto or ""
            return f"{acao} {objeto}".strip()
        
        return "Compromisso"

    def processar_consulta(self, user_id: int) -> str:
        """Processa consulta √† agenda"""
        cursor = self.db.cursor()
        cursor.execute(
            "SELECT titulo, data, hora FROM compromissos_avancados WHERE user_id = ? ORDER BY data, hora",
            (user_id,)
        )
        compromissos = cursor.fetchall()
        
        if not compromissos:
            return "üìÖ *Sua agenda est√° vazia.*"
        
        resposta = "üìÖ **SUA AGENDA AVAN√áADA**\n\n"
        for titulo, data, hora in compromissos:
            resposta += f"‚Ä¢ **{titulo}**\n  üìÖ {data} ‚è∞ {hora}\n\n"
        
        return resposta

    def gerar_resposta_geral(self, intencao: TipoIntencao, texto: str) -> str:
        """Resposta para inten√ß√µes n√£o relacionadas a agendamento"""
        if intencao == TipoIntencao.SAUDACAO:
            return "üëã Ol√°! Sou seu assistente inteligente. Posso ajudar com agendamentos complexos como 'Visitar o pai no hospital √†s 2 da tarde'!"
        else:
            return """ü§ñ **Assistente Inteligente**

üí° **Exemplos que entendo:**
‚Ä¢ `Telefonar ao meu pai √†s 10h30`
‚Ä¢ `Visitar o m√©dico no hospital √†s 2 da tarde` 
‚Ä¢ `Buscar filhos na escola amanh√£ 17h`
‚Ä¢ `Reuni√£o com cliente sexta 14h`

üéØ **Fale naturalmente que eu entendo!**"""

# =============================================
# HANDLERS DO BOT
# =============================================

assistente = AssistenteAvancado()

def start(update: Update, context: CallbackContext):
    user = update.message.from_user
    
    mensagem = f"""
üß† **Ol√° {user.first_name}!**

Sou seu **Assistente Pessoal com IA Avan√ßada**! 

üéØ **AGORA ENTENDO LINGUAGEM NATURAL COMPLEXA:**

‚Ä¢ `"Visitar o meu pai no hospital √†s 2:00 da tarde"` ‚úÖ
‚Ä¢ `"Telefonar √† m√£e amanh√£ 10h30"` ‚úÖ  
‚Ä¢ `"Buscar filhos na escola sexta 17h"` ‚úÖ
‚Ä¢ `"Reuni√£o com cliente no escrit√≥rio segunda 9h"` ‚úÖ

üí° **Fale exatamente como falaria com uma pessoa!**

**Experimente uma frase complexa agora!** üöÄ
    """
    
    update.message.reply_text(mensagem, parse_mode='Markdown')

def handle_message(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    texto = update.message.text
    
    print(f"üß† Processando: '{texto}'")
    
    try:
        resposta = assistente.processar_mensagem(texto, user_id)
        update.message.reply_text(resposta, parse_mode='Markdown')
        
    except Exception as e:
        print(f"‚ùå Erro no processamento: {e}")
        update.message.reply_text(
            "‚ùå **Erro no processamento.** Tente reformular a frase.",
            parse_mode='Markdown'
        )

def main():
    print("üß† Iniciando Sistema de IA Avan√ßada...")
    
    try:
        updater = Updater(BOT_TOKEN, use_context=True)
        dp = updater.dispatcher
        
        dp.add_handler(CommandHandler("start", start))
        dp.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_message))
        
        updater.start_polling()
        
        print("‚úÖ Sistema de IA ativo!")
        print("üß† Aguardando frases complexas...")
        print("üí° Teste: 'Visitar o meu pai no hospital √†s 2:00 da tarde'")
        
        updater.idle()
        
    except Exception as e:
        print(f"‚ùå Erro: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
